---
name: Build and Publish RPM Packages

'on':
  workflow_dispatch:
    inputs:
      kernel_types:
        description: >-
          Kernel types to build (comma-separated: main, bazzite,
          or main,bazzite)
        required: false
        type: string
        default: 'main'
      kernel_version:
        description: 'Specific kernel version (leave empty for latest)'
        required: false
        type: string
        default: ''
      maccel_version:
        description: 'Maccel version to build (e.g., v0.5.6)'
        required: false
        type: string
        default: ''
      build_kmod:
        description: 'Build kmod package'
        required: false
        type: boolean
        default: true
      build_cli:
        description: >-
          Build CLI package (only built for main kernel type)
        required: false
        type: boolean
        default: true
      container_image:
        description: >-
          Container image for build (leave empty to use build.conf default)
        required: false
        type: string
        default: ''
      fedora_version:
        description: >-
          Fedora version (leave empty to use build.conf default)
        required: false
        type: string
        default: ''
      release_type:
        description: 'Release type (stable or testing)'
        required: false
        type: choice
        options:
          - stable
          - testing
        default: 'stable'
  workflow_call:
    inputs:
      kernel_types:
        description: >-
          Kernel types to build (comma-separated: main, bazzite,
          or main,bazzite)
        required: false
        type: string
        default: 'main'
      kernel_version:
        description: 'Specific kernel version (leave empty for latest)'
        required: false
        type: string
        default: ''
      maccel_version:
        description: 'Maccel version to build (e.g., v0.5.6)'
        required: false
        type: string
        default: ''
      build_kmod:
        description: 'Build kmod package'
        required: false
        type: boolean
        default: true
      build_cli:
        description: >-
          Build CLI package (only built for main kernel type)
        required: false
        type: boolean
        default: true
      container_image:
        description: >-
          Container image for build (leave empty to use build.conf default)
        required: false
        type: string
        default: ''
      fedora_version:
        description: >-
          Fedora version (leave empty to use build.conf default)
        required: false
        type: string
        default: ''
      release_type:
        description: 'Release type (stable or testing)'
        required: false
        type: string
        default: 'stable'

permissions:
  contents: write
  packages: write
  actions: read

jobs:
  load-config:
    runs-on: ubuntu-latest
    outputs:
      container_image: ${{ steps.config.outputs.container_image }}
      container_version: ${{ steps.config.outputs.container_version }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Load configuration
        id: config
        run: |
          source build.conf

          # Use workflow inputs if provided, otherwise use config defaults
          INPUT_IMAGE="${{ github.event.inputs.container_image }}"
          INPUT_VERSION="${{ github.event.inputs.fedora_version }}"

          FINAL_IMAGE="${INPUT_IMAGE:-$CONTAINER_IMAGE}"
          FINAL_VERSION="${INPUT_VERSION:-$CONTAINER_VERSION}"

          echo "container_image=$FINAL_IMAGE" >> $GITHUB_OUTPUT
          echo "container_version=$FINAL_VERSION" >> $GITHUB_OUTPUT

  generate-matrix:
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.set-matrix.outputs.matrix }}
    steps:
      - name: Generate build matrix
        id: set-matrix
        run: |
          KERNEL_TYPES="${{ inputs.kernel_types }}"

          # Parse comma-separated kernel types
          IFS=',' read -ra TYPES <<< "$KERNEL_TYPES"

          # Build JSON matrix
          MATRIX_JSON='{"include":['
          FIRST=true
          CLI_ASSIGNED=false  # Track if we've assigned CLI to a kernel type yet

          for TYPE in "${TYPES[@]}"; do
            # Trim whitespace
            TYPE=$(echo "$TYPE" | xargs)

            if [ "$FIRST" = true ]; then
              FIRST=false
            else
              MATRIX_JSON="$MATRIX_JSON,"
            fi

            # Assign CLI build to the first kernel type if build_cli is enabled
            if [ "${{ inputs.build_cli }}" = "true" ] && [ "$CLI_ASSIGNED" = "false" ]; then
              BUILD_CLI="true"
              CLI_ASSIGNED=true
            else
              BUILD_CLI="false"
            fi

            MATRIX_JSON="$MATRIX_JSON"'{"kernel_type":"'"$TYPE"'",'
            MATRIX_JSON="$MATRIX_JSON"'"build_cli":"'"$BUILD_CLI"'"}'
          done

          MATRIX_JSON="$MATRIX_JSON"']}'

          echo "Generated matrix: $MATRIX_JSON"
          echo "matrix=$MATRIX_JSON" >> $GITHUB_OUTPUT

  resolve-versions:
    needs: generate-matrix
    runs-on: ubuntu-latest
    strategy:
      matrix: ${{ fromJson(needs.generate-matrix.outputs.matrix) }}
    outputs:
      maccel_version: ${{ steps.maccel.outputs.maccel_version }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y skopeo jq

      - name: Determine maccel version
        id: maccel
        run: |
          set -euo pipefail
          echo "::group::Determining maccel version"

          # Use workflow input if provided, otherwise read from file
          INPUT_VERSION="${{ inputs.maccel_version }}"
          if [ -n "$INPUT_VERSION" ]; then
            echo "maccel_version=$INPUT_VERSION" >> $GITHUB_OUTPUT
            echo "Using maccel version from workflow input: $INPUT_VERSION"
          elif [ -f .external_versions ]; then
            source .external_versions
            if [ -z "${MACCEL_VERSION:-}" ]; then
              echo "::endgroup::"
              echo "::error::MACCEL_VERSION not set in .external_versions"
              exit 1
            fi
            echo "maccel_version=$MACCEL_VERSION" >> $GITHUB_OUTPUT
            echo "Using maccel version from .external_versions: $MACCEL_VERSION"
          else
            echo "::endgroup::"
            echo "::error::No maccel version specified"
            echo "::error::.external_versions file not found"
            echo "::error::Provide maccel_version input or ensure"
            echo "::error::.external_versions exists"
            exit 1
          fi

          echo "::endgroup::"

      - name: Resolve kernel version
        id: resolve
        run: |
          set -euo pipefail
          KERNEL_TYPE="${{ matrix.kernel_type }}"
          EXPLICIT_VERSION="${{ inputs.kernel_version }}"

          echo "::group::Resolving kernel version for $KERNEL_TYPE"

          # Make script executable
          chmod +x scripts/resolve-kernel-version.sh

          # Resolve kernel version with error handling
          if [ -n "$EXPLICIT_VERSION" ]; then
            if ! KERNEL_VERSION=$(./scripts/resolve-kernel-version.sh \
              --kernel-type "$KERNEL_TYPE" \
              --version "$EXPLICIT_VERSION"); then
              echo "::endgroup::"
              echo "::error::Failed to resolve kernel version"
              echo "::error::Kernel type: $KERNEL_TYPE"
              echo "::error::Explicit version: $EXPLICIT_VERSION"
              exit 1
            fi
          else
            if ! KERNEL_VERSION=$(./scripts/resolve-kernel-version.sh \
              --kernel-type "$KERNEL_TYPE"); then
              echo "::endgroup::"
              echo "::error::Failed to resolve kernel version"
              echo "::error::Kernel type: $KERNEL_TYPE"
              exit 1
            fi
          fi

          # Validate we got a version
          if [ -z "$KERNEL_VERSION" ]; then
            echo "::endgroup::"
            echo "::error::Kernel version resolution returned empty result"
            exit 1
          fi

          echo "kernel_version=$KERNEL_VERSION" >> $GITHUB_OUTPUT
          echo "✓ Resolved kernel version: $KERNEL_VERSION"

          # Store in file for build-rpm job to access
          mkdir -p /tmp/versions
          echo "$KERNEL_VERSION" > "/tmp/versions/${KERNEL_TYPE}_kernel_version"

          echo "::endgroup::"

      - name: Upload version info
        uses: actions/upload-artifact@v4
        with:
          name: version-${{ matrix.kernel_type }}
          path: /tmp/versions/${{ matrix.kernel_type }}_kernel_version

  build-rpm:
    needs: [load-config, generate-matrix, resolve-versions]
    runs-on: ubuntu-latest
    strategy:
      matrix: ${{ fromJson(needs.generate-matrix.outputs.matrix) }}
      fail-fast: false
    container:
      image: >-
        ${{ needs.load-config.outputs.container_image }}:${{
        needs.load-config.outputs.container_version }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Download version info
        uses: actions/download-artifact@v4
        with:
          name: version-${{ matrix.kernel_type }}
          path: /tmp/versions

      - name: Load kernel version
        id: load_version
        run: |
          KERNEL_TYPE="${{ matrix.kernel_type }}"
          KERNEL_VERSION=$(cat "/tmp/versions/${KERNEL_TYPE}_kernel_version")
          echo "kernel_version=$KERNEL_VERSION" >> $GITHUB_OUTPUT
          echo "Loaded kernel version for $KERNEL_TYPE: $KERNEL_VERSION"

      - name: Load maccel version
        id: load_maccel
        run: |
          # Use maccel version from resolve-versions job output
          MACCEL_VERSION="${{ needs.resolve-versions.outputs.maccel_version }}"
          echo "maccel_version=$MACCEL_VERSION" >> $GITHUB_OUTPUT
          echo "Using maccel version from resolve-versions: $MACCEL_VERSION"

      - name: Install build dependencies
        run: |
          # Step 1: Install base RPM build tools and git
          dnf install -y rpm-build rpmdevtools rpmlint createrepo_c \
            rpm-sign gnupg2 pinentry spectool kmodtool curl jq git

          # Step 2: Install BuildRequires from spec files
          KERNEL_VERSION="${{ steps.load_version.outputs.kernel_version }}"
          MACCEL_VERSION="${{ steps.load_maccel.outputs.maccel_version }}"
          
          for spec in specs/*.spec; do
            if [[ "$spec" == *"kmod"* ]]; then
              # Provide actual kernel_version for kmod spec parsing
              dnf builddep -y --define "kernel_version ${KERNEL_VERSION}" \
                --define "version ${MACCEL_VERSION#v}" \
                --define "release 1" "$spec"
            else
              dnf builddep -y "$spec"
            fi
          done

      - name: Setup RPM build tree
        run: rpmdev-setuptree

      - name: Fetch kernel-devel packages
        if: inputs.build_kmod == true
        run: |
          set -euo pipefail
          KERNEL_VERSION="${{ steps.load_version.outputs.kernel_version }}"
          KERNEL_TYPE="${{ matrix.kernel_type }}"
          FEDORA_VERSION="${{ needs.load-config.outputs.container_version }}"

          # Make script executable
          chmod +x scripts/fetch-kernel-packages.sh

          # Fetch kernel packages with error handling
          echo "::group::Fetching kernel-devel packages"
          if ! ./scripts/fetch-kernel-packages.sh \
            --kernel-version "$KERNEL_VERSION" \
            --kernel-type "$KERNEL_TYPE" \
            --fedora-version "$FEDORA_VERSION" \
            --output-dir ~/kernel-packages; then
            echo "::endgroup::"
            echo "::error::Failed to fetch kernel-devel packages"
            echo "::error::Kernel version: $KERNEL_VERSION"
            echo "::error::Kernel type: $KERNEL_TYPE"
            echo "::error::Kernel version not available in repository"
            echo "::error::For main kernel: Check"
            echo "::error::https://kojipkgs.fedoraproject.org/packages/kernel/"
            echo "::error::For bazzite kernel: Check"
            echo "::error::github.com/bazzite-org/kernel-bazzite/releases"
            exit 1
          fi
          echo "::endgroup::"

      - name: Verify kernel-devel availability
        if: inputs.build_kmod == true
        run: |
          set -euo pipefail
          echo "::group::Verifying kernel-devel packages"

          # Check that packages were downloaded
          if ! ls ~/kernel-packages/kernel-devel*.rpm 1>/dev/null 2>&1; then
            echo "::error::No kernel-devel packages found in ~/kernel-packages/"
            echo "::error::Package fetch may have failed silently"
            exit 1
          fi

          # Verify packages are not empty
          for pkg in ~/kernel-packages/kernel-devel*.rpm; do
            if [ ! -s "$pkg" ]; then
              echo "::error::Package file is empty: $pkg"
              exit 1
            fi
            echo "✓ Found: $(basename "$pkg") ($(stat -c%s "$pkg") bytes)"
          done

          echo "::endgroup::"

      - name: Install kernel-devel
        if: inputs.build_kmod == true
        run: |
          set -euo pipefail
          echo "::group::Installing kernel-devel packages"

          KERNEL_TYPE="${{ matrix.kernel_type }}"
          KERNEL_VERSION="${{ steps.load_version.outputs.kernel_version }}"

          # For Bazzite kernels, only install kernel-devel (not kernel-devel-matched)
          # kernel-devel-matched requires kernel-core which isn't available for Bazzite
          if [[ "$KERNEL_TYPE" == "bazzite" ]]; then
            echo "Installing kernel-devel only (Bazzite kernel)..."
            if ! dnf install -y ~/kernel-packages/kernel-devel-${KERNEL_VERSION}.rpm; then
              echo "::endgroup::"
              echo "::error::Failed to install kernel-devel package"
              exit 1
            fi
          else
            echo "Installing all kernel-devel packages (main kernel)..."
            if ! dnf install -y ~/kernel-packages/kernel-devel*.rpm; then
              echo "::endgroup::"
              echo "::error::Failed to install kernel-devel packages"
              echo "::error::Package corruption or dependency issues"
              exit 1
            fi
          fi

          # Verify installation
          if ! rpm -q "kernel-devel-${KERNEL_VERSION}"; then
            echo "::endgroup::"
            echo "::error::kernel-devel package not found after installation"
            echo "::error::Expected: kernel-devel-${KERNEL_VERSION}"
            exit 1
          fi

          echo "✓ Successfully installed kernel-devel-${KERNEL_VERSION}"
          echo "::endgroup::"

      - name: Determine release number
        id: release
        run: |
          set -euo pipefail
          MACCEL_VERSION="${{ steps.load_maccel.outputs.maccel_version }}"
          KERNEL_VERSION="${{ steps.load_version.outputs.kernel_version }}"
          KERNEL_TYPE="${{ matrix.kernel_type }}"
          RELEASE_TYPE="${{ inputs.release_type }}"

          echo "::group::Determining release number"

          # Make script executable
          chmod +x scripts/determine-release-number.sh

          # Determine release number with error handling
          if ! RELEASE_NUMBER=$(./scripts/determine-release-number.sh \
            --maccel-version "$MACCEL_VERSION" \
            --kernel-version "$KERNEL_VERSION" \
            --kernel-type "$KERNEL_TYPE" \
            --release-type "$RELEASE_TYPE" \
            --repo "${{ github.repository }}"); then
            echo "::endgroup::"
            echo "::error::Failed to determine release number"
            echo "::error::Maccel version: $MACCEL_VERSION"
            echo "::error::Kernel version: $KERNEL_VERSION"
            echo "::error::Kernel type: $KERNEL_TYPE"
            exit 1
          fi

          # Validate release number is a positive integer
          if ! [[ "$RELEASE_NUMBER" =~ ^[0-9]+$ ]]; then
            echo "::endgroup::"
            echo "::error::Invalid release number: $RELEASE_NUMBER"
            echo "::error::Expected a positive integer"
            exit 1
          fi

          echo "release_number=$RELEASE_NUMBER" >> $GITHUB_OUTPUT
          echo "✓ Determined release number: $RELEASE_NUMBER"
          echo "::endgroup::"

      - name: Determine CLI release number
        id: cli-release
        if: inputs.build_cli == true && matrix.build_cli == 'true'
        run: |
          set -euo pipefail
          MACCEL_VERSION="${{ steps.load_maccel.outputs.maccel_version }}"
          RELEASE_TYPE="${{ inputs.release_type }}"

          echo "::group::Determining CLI release number"

          # Make script executable
          chmod +x scripts/determine-cli-release-number.sh

          # Determine CLI release number with error handling
          if ! CLI_RELEASE_NUMBER=$(./scripts/determine-cli-release-number.sh \
            --maccel-version "$MACCEL_VERSION" \
            --release-type "$RELEASE_TYPE" \
            --repo "${{ github.repository }}"); then
            echo "::endgroup::"
            echo "::error::Failed to determine CLI release number"
            echo "::error::Maccel version: $MACCEL_VERSION"
            exit 1
          fi

          # Validate release number is a positive integer
          if ! [[ "$CLI_RELEASE_NUMBER" =~ ^[0-9]+$ ]]; then
            echo "::endgroup::"
            echo "::error::Invalid CLI release number: $CLI_RELEASE_NUMBER"
            echo "::error::Expected a positive integer"
            exit 1
          fi

          echo "cli_release_number=$CLI_RELEASE_NUMBER" >> $GITHUB_OUTPUT
          echo "✓ Determined CLI release number: $CLI_RELEASE_NUMBER"
          echo "::endgroup::"

      - name: Download maccel source
        run: |
          KERNEL_VERSION="${{ steps.load_version.outputs.kernel_version }}"
          MACCEL_VERSION="${{ steps.load_maccel.outputs.maccel_version }}"
          
          for spec in specs/*.spec; do
            if [[ "$spec" == *"kmod"* ]]; then
              # Provide kernel_version for kmod spec parsing
              spectool -g -R --define "kernel_version ${KERNEL_VERSION}" \
                --define "version ${MACCEL_VERSION#v}" "$spec"
            else
              spectool -g -R "$spec"
            fi
          done

      - name: Copy spec files
        run: |
          cp specs/*.spec ~/rpmbuild/SPECS/

      - name: Build kmod-maccel
        if: inputs.build_kmod == true
        run: |
          set -euo pipefail
          cd ~/rpmbuild/SPECS

          KERNEL_VERSION="${{ steps.load_version.outputs.kernel_version }}"
          MACCEL_VERSION="${{ steps.load_maccel.outputs.maccel_version }}"
          RELEASE_NUMBER="${{ steps.release.outputs.release_number }}"

          # Strip 'v' prefix from version if present
          VERSION="${MACCEL_VERSION#v}"

          echo "::group::Building kmod-maccel for ${{ matrix.kernel_type }}"
          echo "  Kernel version: $KERNEL_VERSION"
          echo "  Maccel version: $VERSION"
          echo "  Release number: $RELEASE_NUMBER"

          # Build with log capture
          BUILD_LOG="/tmp/kmod-build.log"
          if ! rpmbuild --define "kernel_version ${KERNEL_VERSION}" \
                   --define "version ${VERSION}" \
                   --define "release ${RELEASE_NUMBER}" \
                   -ba maccel-kmod.spec 2>&1 | tee "$BUILD_LOG"; then
            echo "::endgroup::"
            echo "::error::kmod-maccel build failed"
            echo "::group::Build log (last 50 lines)"
            tail -n 50 "$BUILD_LOG"
            echo "::endgroup::"
            echo "::error::Check the build log above for compilation errors"
            exit 1
          fi

          # Verify build output
          if ! ls ~/rpmbuild/RPMS/x86_64/kmod-maccel-*.rpm \
              1>/dev/null 2>&1; then
            echo "::endgroup::"
            echo "::error::Build completed but no kmod package found"
            echo "::error::Expected package in ~/rpmbuild/RPMS/x86_64/"
            exit 1
          fi

          echo "✓ Successfully built kmod-maccel"
          ls -lh ~/rpmbuild/RPMS/x86_64/kmod-maccel-*.rpm
          echo "::endgroup::"

      - name: Build maccel CLI
        if: inputs.build_cli == true && matrix.build_cli == 'true'
        run: |
          set -euo pipefail
          cd ~/rpmbuild/SPECS

          MACCEL_VERSION="${{ steps.load_maccel.outputs.maccel_version }}"
          CLI_RELEASE_NUMBER="${{ steps.cli-release.outputs.cli_release_number }}"

          # Strip 'v' prefix from version if present
          VERSION="${MACCEL_VERSION#v}"

          echo "::group::Building maccel CLI"
          echo "  Maccel version: $VERSION"
          echo "  CLI release number: $CLI_RELEASE_NUMBER"

          # Build with log capture
          BUILD_LOG="/tmp/cli-build.log"
          if ! rpmbuild --define "version ${VERSION}" \
                   --define "release ${CLI_RELEASE_NUMBER}" \
                   -ba maccel.spec 2>&1 | tee "$BUILD_LOG"; then
            echo "::endgroup::"
            echo "::error::maccel CLI build failed"
            echo "::group::Build log (last 50 lines)"
            tail -n 50 "$BUILD_LOG"
            echo "::endgroup::"
            echo "::error::Check the build log above for compilation errors"
            exit 1
          fi

          # Verify build output
          if ! ls ~/rpmbuild/RPMS/x86_64/maccel-*.rpm 1>/dev/null 2>&1; then
            echo "::endgroup::"
            echo "::error::Build completed but no CLI package found"
            echo "::error::Expected package in ~/rpmbuild/RPMS/x86_64/"
            exit 1
          fi

          echo "✓ Successfully built maccel CLI"
          ls -lh ~/rpmbuild/RPMS/x86_64/maccel-*.rpm
          echo "::endgroup::"

      - name: Lint packages
        run: |
          rpmlint ~/rpmbuild/RPMS/x86_64/*.rpm || true
        continue-on-error: true

      - name: Prepare release packages
        run: |
          set -euo pipefail
          echo "::group::Preparing release packages"
          mkdir -p release-packages

          # Copy kmod packages if built
          if [ "${{ inputs.build_kmod }}" == "true" ]; then
            if ls ~/rpmbuild/RPMS/x86_64/kmod-maccel-*.rpm \
                1>/dev/null 2>&1; then
              cp ~/rpmbuild/RPMS/x86_64/kmod-maccel-*.rpm \
                release-packages/
              echo "✓ Copied kmod packages"
            else
              echo "::endgroup::"
              echo "::error::kmod package build requested but not found"
              echo "::error::Expected packages in ~/rpmbuild/RPMS/x86_64/"
              ls -la ~/rpmbuild/RPMS/x86_64/ || true
              exit 1
            fi
          fi

          # Copy CLI packages if built (only for main kernel type)
          if [ "${{ inputs.build_cli }}" == "true" ] && \
             [ "${{ matrix.build_cli }}" == "true" ]; then
            if ls ~/rpmbuild/RPMS/x86_64/maccel-*.rpm 1>/dev/null 2>&1; then
              cp ~/rpmbuild/RPMS/x86_64/maccel-*.rpm release-packages/
              echo "✓ Copied CLI packages"
            else
              echo "::endgroup::"
              echo "::error::CLI package build requested but not found"
              echo "::error::Expected packages in ~/rpmbuild/RPMS/x86_64/"
              ls -la ~/rpmbuild/RPMS/x86_64/ || true
              exit 1
            fi
          fi

          # Copy source RPMs if any packages were built
          if ls ~/rpmbuild/SRPMS/*.src.rpm 1>/dev/null 2>&1; then
            cp ~/rpmbuild/SRPMS/*.src.rpm release-packages/
            echo "✓ Copied source RPMs"
          fi

          # Verify we have at least one package
          if ! ls release-packages/*.rpm 1>/dev/null 2>&1; then
            echo "::endgroup::"
            echo "::error::No packages found to release"
            echo "::error::At least one package should have been built"
            exit 1
          fi

          echo "Release packages prepared:"
          ls -lh release-packages/
          echo "::endgroup::"

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: rpm-packages-${{ matrix.kernel_type }}
          path: release-packages/

  publish-release:
    needs: [build-rpm, resolve-versions]
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts/
          pattern: rpm-packages-*
          merge-multiple: true

      - name: Verify downloaded packages
        run: |
          set -euo pipefail
          echo "::group::Verifying downloaded packages"

          if [ ! -d "artifacts" ]; then
            echo "::error::Artifacts directory not found"
            exit 1
          fi

          if ! ls artifacts/*.rpm 1>/dev/null 2>&1; then
            echo "::error::No RPM packages found in artifacts"
            exit 1
          fi

          echo "Downloaded packages:"
          ls -lh artifacts/

          for pkg in artifacts/*.rpm; do
            if [ ! -s "$pkg" ]; then
              echo "::error::Package file is empty: $pkg"
              exit 1
            fi
          done

          echo "✓ All packages verified"
          echo "::endgroup::"ST5 ZLIB BZIP2 ZIP Uncompressed
          GPG_CONF

          # Configure RPM to use wrapper script with SHA256
          cat > ~/.rpmmacros << 'EOF'
          %_signature gpg
          %_gpg_name ${{ secrets.GPG_KEY_ID }}
          %__gpg /tmp/gpg-sign-wrapper.sh
          %_gpg_digest_algo sha256
          EOF

          echo "RPM macros configured:"
          cat ~/.rpmmacros

          # Create passphrase file for GPG
          echo "$GPG_PASSPHRASE" > /tmp/gpg-passphrase
          chmod 600 /tmp/gpg-passphrase
          
          # Update wrapper to use passphrase file
          cat > /tmp/gpg-sign-wrapper.sh << 'WRAPPER_EOF'
          #!/bin/bash
          /usr/bin/gpg \
            --batch \
            --pinentry-mode loopback \
            --passphrase-file /tmp/gpg-passphrase \
            "$@"
          WRAPPER_EOF
          chmod +x /tmp/gpg-sign-wrapper.sh
          
          # Test signing with the updated wrapper
          echo "Testing signing with passphrase file..."
          if ! echo "test" | /tmp/gpg-sign-wrapper.sh --clearsign -u "${{ secrets.GPG_KEY_ID }}" > /dev/null 2>&1; then
            echo "::error::GPG signing test failed"
            exit 1
          fi
          echo "✓ GPG signing test passed"

          # Sign all RPM packages with verbose output
          cd artifacts
          SIGN_FAILED=0
          for rpm in *.rpm; do
            if [ -f "$rpm" ]; then
              echo "Signing $rpm"
              echo "Running: rpm --addsign --define '_gpg_name ${{ secrets.GPG_KEY_ID }}' --define '__gpg /tmp/gpg-sign-wrapper.sh' $rpm"
              if ! rpm --addsign --define "_gpg_name ${{ secrets.GPG_KEY_ID }}" --define "__gpg /tmp/gpg-sign-wrapper.sh" "$rpm" 2>&1; then
                echo "::error::Failed to sign package: $rpm"
                SIGN_FAILED=1
              fi
              
              # Verify signature immediately after signing
              echo "Checking signature on $rpm..."
              rpm --checksig -v "$rpm" 2>&1 || true
              
              # Check if GPG signature exists
              echo "Checking for GPG signature..."
              rpm -qp --qf '%{SIGPGP:pgpsig}\n' "$rpm" 2>&1 || echo "No GPG signature found"
            fi
          done

          if [ $SIGN_FAILED -eq 1 ]; then
            echo "::endgroup::"
            echo "::error::One or more packages failed to sign"
            exit 1
          fi

          echo "✓ All packages signed successfully"
          echo "::endgroup::"

      - name: Verify package signatures
        run: |
          set -euo pipefail
          echo "::group::Verifying package signatures"

          cd artifacts
          VERIFY_FAILED=0
          for rpm in *.rpm; do
            if [ -f "$rpm" ]; then
              echo "Verifying signature for $rpm"
              if ! rpm --checksig -v "$rpm" 2>&1 | grep -qi "OpenPGP.*OK"; then
                echo "::error::Signature verification failed for: $rpm"
                rpm --checksig -v "$rpm" || true
                VERIFY_FAILED=1
              else
                echo "✓ Signature valid for $rpm"
              fi
            fi
          done

          if [ $VERIFY_FAILED -eq 1 ]; then
            echo "::endgroup::"
            echo "::error::One or more packages have invalid signatures"
            echo "::error::Refusing to publish unsigned/invalid packages"
            exit 1
          fi

          echo "✓ All package signatures verified"
          echo "::endgroup::"

      - name: Prepare release notes
        id: release_notes
        run: |
          VER="${{ needs.resolve-versions.outputs.maccel_version }}"
          KERNEL_TYPES="${{ inputs.kernel_types }}"
          RELEASE_TYPE="${{ inputs.release_type }}"

          {
            echo "notes<<EOF"
            echo "## ⚠️ Package Signing & Distribution"
            echo ""
            echo "The RPM packages in this repository are **unsigned**. For signed, verified packages with automatic updates, use the central RPM repository:"
            echo ""
            echo "### Install from Central Repository (Recommended)"
            echo ""
            echo "\`\`\`bash"
            echo "# Add the central repository (stable channel)"
            echo "sudo curl -o /etc/yum.repos.d/stable.repo \\"
            echo "  https://abirkel.github.io/rpm-repo/repo/stable.repo"
            echo ""
            echo "# Install"
            echo "sudo dnf install maccel"
            echo "\`\`\`"
            echo ""
            echo "The GPG key is automatically imported from the repository configuration."
            echo ""
            echo "### Install from This Repository (Unsigned)"
            echo ""
            echo "If you prefer to install directly from this repository:"
            echo ""
            echo "\`\`\`bash"
            echo "# Download and install RPM manually"
            echo "sudo dnf install <rpm-url-from-release>"
            echo "\`\`\`"
            echo ""
            echo "---"
            echo ""
            echo "## Release Information"
            echo ""
            echo "**Maccel Version:** \`${VER}\`"
            echo "**Kernel Types:** $KERNEL_TYPES"
            echo "**Release Type:** $RELEASE_TYPE"
            echo ""
            echo "> **Note:** The kmod packages are built for specific kernel versions. Install the package matching your kernel type (main for Aurora, bazzite for Bazzite)."
            echo "EOF"
          } >> $GITHUB_OUTPUT

      - name: Prepare release title
        id: release_title
        run: |
          set -euo pipefail
          VER="${{ needs.resolve-versions.outputs.maccel_version }}"
          RELEASE_TYPE="${{ inputs.release_type }}"

          # Strip 'v' prefix if present
          VERSION="${VER#v}"

          TITLE="v${VERSION}-${RELEASE_TYPE}"
          TAG="v${VERSION}-${RELEASE_TYPE}"

          echo "title=$TITLE" >> $GITHUB_OUTPUT
          echo "tag=$TAG" >> $GITHUB_OUTPUT
          echo "Release title: $TITLE"

      - name: Create GitHub release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.release_title.outputs.tag }}
          name: ${{ steps.release_title.outputs.title }}
          files: artifacts/*.rpm
          body: ${{ steps.release_notes.outputs.notes }}
          fail_on_unmatched_files: false


  publish-to-repo-main:
    needs: [build-rpm, resolve-versions, load-config]
    if: contains(inputs.kernel_types, 'main')
    runs-on: ubuntu-latest
    steps:
      - name: Trigger rpm-repo signing and publishing
        run: |
          gh workflow run sign-and-publish.yml \
            --repo abirkel/rpm-repo \
            -f builder_repo=${{ github.repository }} \
            -f run_id=${{ github.run_id }} \
            -f artifact_name=rpm-packages-main \
            -f distro=fedora \
            -f release=${{ needs.load-config.outputs.container_version }} \
            -f arch=x86_64 \
            -f build_type=${{ inputs.release_type }}
        env:
          GH_TOKEN: ${{ secrets.RPM_REPO_DISPATCH_TOKEN }}

  publish-to-repo-bazzite:
    needs: [build-rpm, resolve-versions, load-config]
    if: contains(inputs.kernel_types, 'bazzite')
    runs-on: ubuntu-latest
    steps:
      - name: Trigger rpm-repo signing and publishing
        run: |
          gh workflow run sign-and-publish.yml \
            --repo abirkel/rpm-repo \
            -f builder_repo=${{ github.repository }} \
            -f run_id=${{ github.run_id }} \
            -f artifact_name=rpm-packages-bazzite \
            -f distro=fedora \
            -f release=${{ needs.load-config.outputs.container_version }} \
            -f arch=x86_64 \
            -f build_type=${{ inputs.release_type }}
        env:
          GH_TOKEN: ${{ secrets.RPM_REPO_DISPATCH_TOKEN }}
