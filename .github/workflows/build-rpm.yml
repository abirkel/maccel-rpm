---
name: Build and Publish RPM Packages

'on':
  workflow_dispatch:
    inputs:
      kernel_types:
        description: >-
          Kernel types to build (comma-separated: main, bazzite,
          or main,bazzite)
        required: false
        type: string
        default: 'main'
      kernel_version:
        description: 'Specific kernel version (leave empty for latest)'
        required: false
        type: string
        default: ''
      maccel_version:
        description: 'Maccel version to build (e.g., v0.5.6)'
        required: false
        type: string
        default: ''
      build_kmod:
        description: 'Build kmod package'
        required: false
        type: boolean
        default: true
      build_cli:
        description: >-
          Build CLI package (only built for main kernel type)
        required: false
        type: boolean
        default: true
      container_image:
        description: >-
          Container image for build (leave empty to use build.conf default)
        required: false
        type: string
        default: ''
      fedora_version:
        description: >-
          Fedora version (leave empty to use build.conf default)
        required: false
        type: string
        default: ''
  workflow_call:
    inputs:
      kernel_types:
        description: >-
          Kernel types to build (comma-separated: main, bazzite,
          or main,bazzite)
        required: false
        type: string
        default: 'main'
      kernel_version:
        description: 'Specific kernel version (leave empty for latest)'
        required: false
        type: string
        default: ''
      maccel_version:
        description: 'Maccel version to build (e.g., v0.5.6)'
        required: false
        type: string
        default: ''
      build_kmod:
        description: 'Build kmod package'
        required: false
        type: boolean
        default: true
      build_cli:
        description: >-
          Build CLI package (only built for main kernel type)
        required: false
        type: boolean
        default: true
      container_image:
        description: >-
          Container image for build (leave empty to use build.conf default)
        required: false
        type: string
        default: ''
      fedora_version:
        description: >-
          Fedora version (leave empty to use build.conf default)
        required: false
        type: string
        default: ''

permissions:
  contents: write
  packages: write

jobs:
  load-config:
    runs-on: ubuntu-latest
    outputs:
      container_image: ${{ steps.config.outputs.container_image }}
      container_version: ${{ steps.config.outputs.container_version }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Load configuration
        id: config
        run: |
          source build.conf

          # Use workflow inputs if provided, otherwise use config defaults
          INPUT_IMAGE="${{ github.event.inputs.container_image }}"
          INPUT_VERSION="${{ github.event.inputs.fedora_version }}"

          FINAL_IMAGE="${INPUT_IMAGE:-$CONTAINER_IMAGE}"
          FINAL_VERSION="${INPUT_VERSION:-$CONTAINER_VERSION}"

          echo "container_image=$FINAL_IMAGE" >> $GITHUB_OUTPUT
          echo "container_version=$FINAL_VERSION" >> $GITHUB_OUTPUT

  generate-matrix:
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.set-matrix.outputs.matrix }}
    steps:
      - name: Generate build matrix
        id: set-matrix
        run: |
          KERNEL_TYPES="${{ inputs.kernel_types }}"

          # Parse comma-separated kernel types
          IFS=',' read -ra TYPES <<< "$KERNEL_TYPES"

          # Build JSON matrix
          MATRIX_JSON='{"include":['
          FIRST=true

          for TYPE in "${TYPES[@]}"; do
            # Trim whitespace
            TYPE=$(echo "$TYPE" | xargs)

            if [ "$FIRST" = true ]; then
              FIRST=false
            else
              MATRIX_JSON="$MATRIX_JSON,"
            fi

            # Only main kernel type builds CLI (if build_cli input is true)
            if [ "$TYPE" = "main" ] && [ "${{ inputs.build_cli }}" = "true" ]; then
              BUILD_CLI="true"
            else
              BUILD_CLI="false"
            fi

            MATRIX_JSON="$MATRIX_JSON"'{"kernel_type":"'"$TYPE"'",'
            MATRIX_JSON="$MATRIX_JSON"'"build_cli":"'"$BUILD_CLI"'"}'
          done

          MATRIX_JSON="$MATRIX_JSON"']}'

          echo "Generated matrix: $MATRIX_JSON"
          echo "matrix=$MATRIX_JSON" >> $GITHUB_OUTPUT

  resolve-versions:
    needs: generate-matrix
    runs-on: ubuntu-latest
    strategy:
      matrix: ${{ fromJson(needs.generate-matrix.outputs.matrix) }}
    outputs:
      maccel_version: ${{ steps.maccel.outputs.maccel_version }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y skopeo jq

      - name: Determine maccel version
        id: maccel
        run: |
          set -euo pipefail
          echo "::group::Determining maccel version"

          # Use workflow input if provided, otherwise read from file
          INPUT_VERSION="${{ inputs.maccel_version }}"
          if [ -n "$INPUT_VERSION" ]; then
            echo "maccel_version=$INPUT_VERSION" >> $GITHUB_OUTPUT
            echo "Using maccel version from workflow input: $INPUT_VERSION"
          elif [ -f .external_versions ]; then
            source .external_versions
            if [ -z "${MACCEL_VERSION:-}" ]; then
              echo "::endgroup::"
              echo "::error::MACCEL_VERSION not set in .external_versions"
              exit 1
            fi
            echo "maccel_version=$MACCEL_VERSION" >> $GITHUB_OUTPUT
            echo "Using maccel version from .external_versions: $MACCEL_VERSION"
          else
            echo "::endgroup::"
            echo "::error::No maccel version specified"
            echo "::error::.external_versions file not found"
            echo "::error::Provide maccel_version input or ensure"
            echo "::error::.external_versions exists"
            exit 1
          fi

          echo "::endgroup::"

      - name: Resolve kernel version
        id: resolve
        run: |
          set -euo pipefail
          KERNEL_TYPE="${{ matrix.kernel_type }}"
          EXPLICIT_VERSION="${{ inputs.kernel_version }}"

          echo "::group::Resolving kernel version for $KERNEL_TYPE"

          # Make script executable
          chmod +x scripts/resolve-kernel-version.sh

          # Resolve kernel version with error handling
          if [ -n "$EXPLICIT_VERSION" ]; then
            if ! KERNEL_VERSION=$(./scripts/resolve-kernel-version.sh \
              --kernel-type "$KERNEL_TYPE" \
              --version "$EXPLICIT_VERSION"); then
              echo "::endgroup::"
              echo "::error::Failed to resolve kernel version"
              echo "::error::Kernel type: $KERNEL_TYPE"
              echo "::error::Explicit version: $EXPLICIT_VERSION"
              exit 1
            fi
          else
            if ! KERNEL_VERSION=$(./scripts/resolve-kernel-version.sh \
              --kernel-type "$KERNEL_TYPE"); then
              echo "::endgroup::"
              echo "::error::Failed to resolve kernel version"
              echo "::error::Kernel type: $KERNEL_TYPE"
              exit 1
            fi
          fi

          # Validate we got a version
          if [ -z "$KERNEL_VERSION" ]; then
            echo "::endgroup::"
            echo "::error::Kernel version resolution returned empty result"
            exit 1
          fi

          echo "kernel_version=$KERNEL_VERSION" >> $GITHUB_OUTPUT
          echo "✓ Resolved kernel version: $KERNEL_VERSION"

          # Store in file for build-rpm job to access
          mkdir -p /tmp/versions
          echo "$KERNEL_VERSION" > "/tmp/versions/${KERNEL_TYPE}_kernel_version"

          echo "::endgroup::"

      - name: Upload version info
        uses: actions/upload-artifact@v4
        with:
          name: version-${{ matrix.kernel_type }}
          path: /tmp/versions/${{ matrix.kernel_type }}_kernel_version

  build-rpm:
    needs: [load-config, generate-matrix, resolve-versions]
    runs-on: ubuntu-latest
    strategy:
      matrix: ${{ fromJson(needs.generate-matrix.outputs.matrix) }}
      fail-fast: false
    container:
      image: >-
        ${{ needs.load-config.outputs.container_image }}:${{
        needs.load-config.outputs.container_version }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Download version info
        uses: actions/download-artifact@v4
        with:
          name: version-${{ matrix.kernel_type }}
          path: /tmp/versions

      - name: Load kernel version
        id: load_version
        run: |
          KERNEL_TYPE="${{ matrix.kernel_type }}"
          KERNEL_VERSION=$(cat "/tmp/versions/${KERNEL_TYPE}_kernel_version")
          echo "kernel_version=$KERNEL_VERSION" >> $GITHUB_OUTPUT
          echo "Loaded kernel version for $KERNEL_TYPE: $KERNEL_VERSION"

      - name: Load maccel version
        id: load_maccel
        run: |
          # Use maccel version from resolve-versions job output
          MACCEL_VERSION="${{ needs.resolve-versions.outputs.maccel_version }}"
          echo "maccel_version=$MACCEL_VERSION" >> $GITHUB_OUTPUT
          echo "Using maccel version from resolve-versions: $MACCEL_VERSION"

      - name: Install build dependencies
        run: |
          # Step 1: Install base RPM build tools and git
          dnf install -y rpm-build rpmdevtools rpmlint createrepo_c \
            rpm-sign gnupg2 pinentry spectool kmodtool curl jq git

          # Step 2: Install BuildRequires from spec files
          KERNEL_VERSION="${{ steps.load_version.outputs.kernel_version }}"
          MACCEL_VERSION="${{ steps.load_maccel.outputs.maccel_version }}"
          
          for spec in specs/*.spec; do
            if [[ "$spec" == *"kmod"* ]]; then
              # Provide actual kernel_version for kmod spec parsing
              dnf builddep -y --define "kernel_version ${KERNEL_VERSION}" \
                --define "version ${MACCEL_VERSION#v}" \
                --define "release 1" "$spec"
            else
              dnf builddep -y "$spec"
            fi
          done

      - name: Setup RPM build tree
        run: rpmdev-setuptree

      - name: Fetch kernel-devel packages
        if: inputs.build_kmod == true
        run: |
          set -euo pipefail
          KERNEL_VERSION="${{ steps.load_version.outputs.kernel_version }}"
          KERNEL_TYPE="${{ matrix.kernel_type }}"
          FEDORA_VERSION="${{ needs.load-config.outputs.container_version }}"

          # Make script executable
          chmod +x scripts/fetch-kernel-packages.sh

          # Fetch kernel packages with error handling
          echo "::group::Fetching kernel-devel packages"
          if ! ./scripts/fetch-kernel-packages.sh \
            --kernel-version "$KERNEL_VERSION" \
            --kernel-type "$KERNEL_TYPE" \
            --fedora-version "$FEDORA_VERSION" \
            --output-dir ~/kernel-packages; then
            echo "::endgroup::"
            echo "::error::Failed to fetch kernel-devel packages"
            echo "::error::Kernel version: $KERNEL_VERSION"
            echo "::error::Kernel type: $KERNEL_TYPE"
            echo "::error::Kernel version not available in repository"
            echo "::error::For main kernel: Check"
            echo "::error::https://kojipkgs.fedoraproject.org/packages/kernel/"
            echo "::error::For bazzite kernel: Check"
            echo "::error::github.com/bazzite-org/kernel-bazzite/releases"
            exit 1
          fi
          echo "::endgroup::"

      - name: Verify kernel-devel availability
        if: inputs.build_kmod == true
        run: |
          set -euo pipefail
          echo "::group::Verifying kernel-devel packages"

          # Check that packages were downloaded
          if ! ls ~/kernel-packages/kernel-devel*.rpm 1>/dev/null 2>&1; then
            echo "::error::No kernel-devel packages found in ~/kernel-packages/"
            echo "::error::Package fetch may have failed silently"
            exit 1
          fi

          # Verify packages are not empty
          for pkg in ~/kernel-packages/kernel-devel*.rpm; do
            if [ ! -s "$pkg" ]; then
              echo "::error::Package file is empty: $pkg"
              exit 1
            fi
            echo "✓ Found: $(basename "$pkg") ($(stat -c%s "$pkg") bytes)"
          done

          echo "::endgroup::"

      - name: Install kernel-devel
        if: inputs.build_kmod == true
        run: |
          set -euo pipefail
          echo "::group::Installing kernel-devel packages"

          KERNEL_TYPE="${{ matrix.kernel_type }}"
          KERNEL_VERSION="${{ steps.load_version.outputs.kernel_version }}"

          # For Bazzite kernels, only install kernel-devel (not kernel-devel-matched)
          # kernel-devel-matched requires kernel-core which isn't available for Bazzite
          if [[ "$KERNEL_TYPE" == "bazzite" ]]; then
            echo "Installing kernel-devel only (Bazzite kernel)..."
            if ! dnf install -y ~/kernel-packages/kernel-devel-${KERNEL_VERSION}.rpm; then
              echo "::endgroup::"
              echo "::error::Failed to install kernel-devel package"
              exit 1
            fi
          else
            echo "Installing all kernel-devel packages (main kernel)..."
            if ! dnf install -y ~/kernel-packages/kernel-devel*.rpm; then
              echo "::endgroup::"
              echo "::error::Failed to install kernel-devel packages"
              echo "::error::Package corruption or dependency issues"
              exit 1
            fi
          fi

          # Verify installation
          if ! rpm -q "kernel-devel-${KERNEL_VERSION}"; then
            echo "::endgroup::"
            echo "::error::kernel-devel package not found after installation"
            echo "::error::Expected: kernel-devel-${KERNEL_VERSION}"
            exit 1
          fi

          echo "✓ Successfully installed kernel-devel-${KERNEL_VERSION}"
          echo "::endgroup::"

      - name: Determine release number
        id: release
        run: |
          set -euo pipefail
          MACCEL_VERSION="${{ steps.load_maccel.outputs.maccel_version }}"
          KERNEL_VERSION="${{ steps.load_version.outputs.kernel_version }}"
          KERNEL_TYPE="${{ matrix.kernel_type }}"

          echo "::group::Determining release number"

          # Make script executable
          chmod +x scripts/determine-release-number.sh

          # Determine release number with error handling
          if ! RELEASE_NUMBER=$(./scripts/determine-release-number.sh \
            --maccel-version "$MACCEL_VERSION" \
            --kernel-version "$KERNEL_VERSION" \
            --kernel-type "$KERNEL_TYPE" \
            --repo "${{ github.repository }}"); then
            echo "::endgroup::"
            echo "::error::Failed to determine release number"
            echo "::error::Maccel version: $MACCEL_VERSION"
            echo "::error::Kernel version: $KERNEL_VERSION"
            echo "::error::Kernel type: $KERNEL_TYPE"
            exit 1
          fi

          # Validate release number is a positive integer
          if ! [[ "$RELEASE_NUMBER" =~ ^[0-9]+$ ]]; then
            echo "::endgroup::"
            echo "::error::Invalid release number: $RELEASE_NUMBER"
            echo "::error::Expected a positive integer"
            exit 1
          fi

          echo "release_number=$RELEASE_NUMBER" >> $GITHUB_OUTPUT
          echo "✓ Determined release number: $RELEASE_NUMBER"
          echo "::endgroup::"

      - name: Download maccel source
        run: |
          KERNEL_VERSION="${{ steps.load_version.outputs.kernel_version }}"
          MACCEL_VERSION="${{ steps.load_maccel.outputs.maccel_version }}"
          
          for spec in specs/*.spec; do
            if [[ "$spec" == *"kmod"* ]]; then
              # Provide kernel_version for kmod spec parsing
              spectool -g -R --define "kernel_version ${KERNEL_VERSION}" \
                --define "version ${MACCEL_VERSION#v}" "$spec"
            else
              spectool -g -R "$spec"
            fi
          done

      - name: Copy spec files
        run: |
          cp specs/*.spec ~/rpmbuild/SPECS/

      - name: Build kmod-maccel
        if: inputs.build_kmod == true
        run: |
          set -euo pipefail
          cd ~/rpmbuild/SPECS

          KERNEL_VERSION="${{ steps.load_version.outputs.kernel_version }}"
          MACCEL_VERSION="${{ steps.load_maccel.outputs.maccel_version }}"
          RELEASE_NUMBER="${{ steps.release.outputs.release_number }}"

          # Strip 'v' prefix from version if present
          VERSION="${MACCEL_VERSION#v}"

          echo "::group::Building kmod-maccel for ${{ matrix.kernel_type }}"
          echo "  Kernel version: $KERNEL_VERSION"
          echo "  Maccel version: $VERSION"
          echo "  Release number: $RELEASE_NUMBER"

          # Build with log capture
          BUILD_LOG="/tmp/kmod-build.log"
          if ! rpmbuild --define "kernel_version ${KERNEL_VERSION}" \
                   --define "version ${VERSION}" \
                   --define "release ${RELEASE_NUMBER}" \
                   -ba maccel-kmod.spec 2>&1 | tee "$BUILD_LOG"; then
            echo "::endgroup::"
            echo "::error::kmod-maccel build failed"
            echo "::group::Build log (last 50 lines)"
            tail -n 50 "$BUILD_LOG"
            echo "::endgroup::"
            echo "::error::Check the build log above for compilation errors"
            exit 1
          fi

          # Verify build output
          if ! ls ~/rpmbuild/RPMS/x86_64/kmod-maccel-*.rpm \
              1>/dev/null 2>&1; then
            echo "::endgroup::"
            echo "::error::Build completed but no kmod package found"
            echo "::error::Expected package in ~/rpmbuild/RPMS/x86_64/"
            exit 1
          fi

          echo "✓ Successfully built kmod-maccel"
          ls -lh ~/rpmbuild/RPMS/x86_64/kmod-maccel-*.rpm
          echo "::endgroup::"

      - name: Build maccel CLI
        if: inputs.build_cli == true && matrix.build_cli == 'true'
        run: |
          set -euo pipefail
          cd ~/rpmbuild/SPECS

          MACCEL_VERSION="${{ steps.load_maccel.outputs.maccel_version }}"
          RELEASE_NUMBER="${{ steps.release.outputs.release_number }}"

          # Strip 'v' prefix from version if present
          VERSION="${MACCEL_VERSION#v}"

          echo "::group::Building maccel CLI"
          echo "  Maccel version: $VERSION"
          echo "  Release number: $RELEASE_NUMBER"

          # Build with log capture
          BUILD_LOG="/tmp/cli-build.log"
          if ! rpmbuild --define "version ${VERSION}" \
                   --define "release ${RELEASE_NUMBER}" \
                   -ba maccel.spec 2>&1 | tee "$BUILD_LOG"; then
            echo "::endgroup::"
            echo "::error::maccel CLI build failed"
            echo "::group::Build log (last 50 lines)"
            tail -n 50 "$BUILD_LOG"
            echo "::endgroup::"
            echo "::error::Check the build log above for compilation errors"
            exit 1
          fi

          # Verify build output
          if ! ls ~/rpmbuild/RPMS/x86_64/maccel-*.rpm 1>/dev/null 2>&1; then
            echo "::endgroup::"
            echo "::error::Build completed but no CLI package found"
            echo "::error::Expected package in ~/rpmbuild/RPMS/x86_64/"
            exit 1
          fi

          echo "✓ Successfully built maccel CLI"
          ls -lh ~/rpmbuild/RPMS/x86_64/maccel-*.rpm
          echo "::endgroup::"

      - name: Lint packages
        run: |
          rpmlint ~/rpmbuild/RPMS/x86_64/*.rpm || true
        continue-on-error: true

      - name: Prepare release packages
        run: |
          set -euo pipefail
          echo "::group::Preparing release packages"
          mkdir -p release-packages

          # Copy kmod packages if built
          if [ "${{ inputs.build_kmod }}" == "true" ]; then
            if ls ~/rpmbuild/RPMS/x86_64/kmod-maccel-*.rpm \
                1>/dev/null 2>&1; then
              cp ~/rpmbuild/RPMS/x86_64/kmod-maccel-*.rpm \
                release-packages/
              echo "✓ Copied kmod packages"
            else
              echo "::endgroup::"
              echo "::error::kmod package build requested but not found"
              echo "::error::Expected packages in ~/rpmbuild/RPMS/x86_64/"
              ls -la ~/rpmbuild/RPMS/x86_64/ || true
              exit 1
            fi
          fi

          # Copy CLI packages if built (only for main kernel type)
          if [ "${{ inputs.build_cli }}" == "true" ] && \
             [ "${{ matrix.build_cli }}" == "true" ]; then
            if ls ~/rpmbuild/RPMS/x86_64/maccel-*.rpm 1>/dev/null 2>&1; then
              cp ~/rpmbuild/RPMS/x86_64/maccel-*.rpm release-packages/
              echo "✓ Copied CLI packages"
            else
              echo "::endgroup::"
              echo "::error::CLI package build requested but not found"
              echo "::error::Expected packages in ~/rpmbuild/RPMS/x86_64/"
              ls -la ~/rpmbuild/RPMS/x86_64/ || true
              exit 1
            fi
          fi

          # Copy source RPMs if any packages were built
          if ls ~/rpmbuild/SRPMS/*.src.rpm 1>/dev/null 2>&1; then
            cp ~/rpmbuild/SRPMS/*.src.rpm release-packages/
            echo "✓ Copied source RPMs"
          fi

          # Verify we have at least one package
          if ! ls release-packages/*.rpm 1>/dev/null 2>&1; then
            echo "::endgroup::"
            echo "::error::No packages found to release"
            echo "::error::At least one package should have been built"
            exit 1
          fi

          echo "Release packages prepared:"
          ls -lh release-packages/
          echo "::endgroup::"

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: rpm-packages-${{ matrix.kernel_type }}
          path: release-packages/

  publish:
    needs: [build-rpm, resolve-versions, load-config]
    runs-on: ubuntu-latest
    container:
      image: >-
        ${{ needs.load-config.outputs.container_image }}:${{
        needs.load-config.outputs.container_version }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts/
          pattern: rpm-packages-*
          merge-multiple: true

      - name: Verify downloaded packages
        run: |
          set -euo pipefail
          echo "::group::Verifying downloaded packages"

          # Check that artifacts directory exists and has packages
          if [ ! -d "artifacts" ]; then
            echo "::error::Artifacts directory not found"
            exit 1
          fi

          if ! ls artifacts/*.rpm 1>/dev/null 2>&1; then
            echo "::error::No RPM packages found in artifacts"
            echo "::error::Build jobs may have failed to produce packages"
            exit 1
          fi

          echo "Downloaded packages:"
          ls -lh artifacts/

          # Verify each package is not empty
          for pkg in artifacts/*.rpm; do
            if [ ! -s "$pkg" ]; then
              echo "::error::Package file is empty: $pkg"
              exit 1
            fi
          done

          echo "✓ All packages verified"
          echo "::endgroup::"

      - name: Install RPM signing tools
        run: |
          dnf install -y rpm-sign gnupg2 createrepo_c rpmsign

      - name: Setup GPG for signing
        run: |
          set -euo pipefail
          echo "::group::Setting up GPG for signing"

          # Decode and import private key
          if ! echo "${{ secrets.GPG_PRIVATE_KEY }}" | \
              base64 -d > private.key; then
            echo "::endgroup::"
            echo "::error::Failed to decode GPG_PRIVATE_KEY"
            echo "::error::Ensure the secret is properly base64 encoded"
            exit 1
          fi

          if ! gpg --batch --passphrase "${{ secrets.GPG_PASSPHRASE }}" \
            --import private.key 2>&1; then
            rm -f private.key
            echo "::endgroup::"
            echo "::error::Failed to import GPG private key"
            echo "::error::Check that GPG_PASSPHRASE is correct"
            exit 1
          fi

          # Set trust level
          if ! echo -e "5\ny\n" | gpg --batch --command-fd 0 \
            --edit-key "${{ secrets.GPG_KEY_ID }}" trust 2>&1; then
            rm -f private.key
            echo "::endgroup::"
            echo "::error::Failed to set trust level for GPG key"
            exit 1
          fi

          rm -f private.key
          echo "✓ GPG configured successfully"
          echo "::endgroup::"

      - name: Sign all RPM packages
        run: |
          set -euo pipefail
          echo "::group::Signing RPM packages"

          # Import public key into RPM database
          gpg --export -a "${{ secrets.GPG_KEY_ID }}" > /tmp/gpg-pubkey.asc
          rpm --import /tmp/gpg-pubkey.asc
          
          # Verify key is in RPM database
          echo "Keys in RPM database:"
          rpm -q gpg-pubkey --qf '%{NAME}-%{VERSION}-%{RELEASE}\t%{SUMMARY}\n'

          # Create GPG wrapper script that handles passphrase
          cat > /tmp/gpg-sign-wrapper.sh << 'WRAPPER_EOF'
          #!/bin/bash
          # GPG wrapper for RPM signing - reads passphrase from environment
          echo "$GPG_PASSPHRASE" | /usr/bin/gpg \
            --batch \
            --pinentry-mode loopback \
            --passphrase-fd 0 \
            "$@"
          WRAPPER_EOF
          chmod +x /tmp/gpg-sign-wrapper.sh

          # Test the wrapper script works
          echo "Testing GPG wrapper..."
          export GPG_PASSPHRASE="${{ secrets.GPG_PASSPHRASE }}"
          if ! echo "test" | /tmp/gpg-sign-wrapper.sh --clearsign -u "${{ secrets.GPG_KEY_ID }}" > /dev/null 2>&1; then
            echo "::error::GPG wrapper test failed - passphrase or key issue"
            exit 1
          fi
          echo "✓ GPG wrapper test passed"

          # List available secret keys with full details
          echo "Available GPG secret keys:"
          gpg --list-secret-keys --keyid-format LONG --with-subkey-fingerprints
          
          # Check key capabilities
          echo ""
          echo "Key capabilities check:"
          gpg --list-keys --with-colons "${{ secrets.GPG_KEY_ID }}" | grep -E "^(pub|sub):" | while IFS=: read -r type trust keylen algo keyid date expires dummy uid_hash dummy2 caps rest; do
            echo "  Type: $type, KeyID: $keyid, Capabilities: $caps"
          done
          
          # Test actual detached signature creation (what RPM uses)
          echo ""
          echo "Testing detached signature creation (RPM-style)..."
          echo "test data" > /tmp/test.txt
          if /tmp/gpg-sign-wrapper.sh --detach-sign -u "${{ secrets.GPG_KEY_ID }}" --armor /tmp/test.txt 2>&1; then
            echo "✓ Detached signature created successfully"
            ls -la /tmp/test.txt.asc
            # Verify the signature
            if gpg --verify /tmp/test.txt.asc /tmp/test.txt 2>&1; then
              echo "✓ Signature verification successful"
            else
              echo "::error::Signature verification FAILED"
            fi
          else
            echo "::error::Failed to create detached signature"
          fi

          # Configure GPG to use SHA256 for digests
          cat > ~/.gnupg/gpg.conf << 'GPG_CONF'
          personal-digest-preferences SHA256
          cert-digest-algo SHA256
          default-preference-list SHA512 SHA384 SHA256 SHA224 AES256 AES192 AES CAST5 ZLIB BZIP2 ZIP Uncompressed
          GPG_CONF

          # Configure RPM to use wrapper script with SHA256
          cat > ~/.rpmmacros << 'EOF'
          %_signature gpg
          %_gpg_name ${{ secrets.GPG_KEY_ID }}
          %__gpg /tmp/gpg-sign-wrapper.sh
          %_gpg_digest_algo sha256
          EOF

          echo "RPM macros configured:"
          cat ~/.rpmmacros

          # Create passphrase file for GPG
          echo "$GPG_PASSPHRASE" > /tmp/gpg-passphrase
          chmod 600 /tmp/gpg-passphrase
          
          # Update wrapper to use passphrase file
          cat > /tmp/gpg-sign-wrapper.sh << 'WRAPPER_EOF'
          #!/bin/bash
          /usr/bin/gpg \
            --batch \
            --pinentry-mode loopback \
            --passphrase-file /tmp/gpg-passphrase \
            "$@"
          WRAPPER_EOF
          chmod +x /tmp/gpg-sign-wrapper.sh
          
          # Test signing with the updated wrapper
          echo "Testing signing with passphrase file..."
          if ! echo "test" | /tmp/gpg-sign-wrapper.sh --clearsign -u "${{ secrets.GPG_KEY_ID }}" > /dev/null 2>&1; then
            echo "::error::GPG signing test failed"
            exit 1
          fi
          echo "✓ GPG signing test passed"

          # Sign all RPM packages with verbose output
          cd artifacts
          SIGN_FAILED=0
          for rpm in *.rpm; do
            if [ -f "$rpm" ]; then
              echo "Signing $rpm"
              echo "Running: rpm --addsign --define '_gpg_name ${{ secrets.GPG_KEY_ID }}' --define '__gpg /tmp/gpg-sign-wrapper.sh' $rpm"
              if ! rpm --addsign --define "_gpg_name ${{ secrets.GPG_KEY_ID }}" --define "__gpg /tmp/gpg-sign-wrapper.sh" "$rpm" 2>&1; then
                echo "::error::Failed to sign package: $rpm"
                SIGN_FAILED=1
              fi
              
              # Verify signature immediately after signing
              echo "Checking signature on $rpm..."
              rpm --checksig -v "$rpm" 2>&1 || true
              
              # Check if GPG signature exists
              echo "Checking for GPG signature..."
              rpm -qp --qf '%{SIGPGP:pgpsig}\n' "$rpm" 2>&1 || echo "No GPG signature found"
            fi
          done

          if [ $SIGN_FAILED -eq 1 ]; then
            echo "::endgroup::"
            echo "::error::One or more packages failed to sign"
            exit 1
          fi

          echo "✓ All packages signed successfully"
          echo "::endgroup::"

      - name: Verify package signatures
        run: |
          set -euo pipefail
          echo "::group::Verifying package signatures"

          cd artifacts
          VERIFY_FAILED=0
          for rpm in *.rpm; do
            if [ -f "$rpm" ]; then
              echo "Verifying signature for $rpm"
              if ! rpm --checksig -v "$rpm" 2>&1 | grep -qi "OpenPGP.*OK"; then
                echo "::error::Signature verification failed for: $rpm"
                rpm --checksig -v "$rpm" || true
                VERIFY_FAILED=1
              else
                echo "✓ Signature valid for $rpm"
              fi
            fi
          done

          if [ $VERIFY_FAILED -eq 1 ]; then
            echo "::endgroup::"
            echo "::error::One or more packages have invalid signatures"
            echo "::error::Refusing to publish unsigned/invalid packages"
            exit 1
          fi

          echo "✓ All package signatures verified"
          echo "::endgroup::"

      - name: Prepare release notes
        id: release_notes
        run: |
          VER="${{ needs.resolve-versions.outputs.maccel_version }}"
          KERNEL_TYPES="${{ inputs.kernel_types }}"
          REPO="${{ github.repository }}"

          {
            echo "notes<<EOF"
            echo "RPM packages for maccel **$VER**"
            echo ""
            echo "**Kernel Types:** $KERNEL_TYPES"
            echo ""
            echo "> **Note:** The kmod packages are built for"
            echo "> specific kernel versions. Install the package"
            echo "> matching your kernel type (main for Aurora,"
            echo "> bazzite for Bazzite)."
            echo ""
            echo "## Installation"
            echo "\`\`\`bash"
            echo "sudo wget \\"
            echo "  https://raw.githubusercontent.com/$REPO/main/maccel.repo \\"
            echo "  -O /etc/yum.repos.d/maccel.repo && \\"
            echo "  sudo dnf install maccel"
            echo "\`\`\`"
            echo ""
            echo "**Post-install:** \`sudo usermod -aG maccel \$USER\`"
            echo "EOF"
          } >> $GITHUB_OUTPUT

      - name: Create or update GitHub release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: build-${{ needs.resolve-versions.outputs.maccel_version }}
          files: artifacts/*.rpm
          body: ${{ steps.release_notes.outputs.notes }}
          fail_on_unmatched_files: false
          # This will update existing release if it exists

      - name: Prepare merged repository
        run: |
          set -euo pipefail
          echo "::group::Preparing merged repository"

          # Install git for gh-pages action
          dnf install -y git

          # Clone existing gh-pages branch to get current packages
          echo "Cloning existing gh-pages branch..."
          git clone --depth=1 --branch=gh-pages \
            https://github.com/${{ github.repository }}.git gh-pages-repo \
            || mkdir -p gh-pages-repo

          # Determine Fedora version and architecture
          FEDORA_VERSION="${{ needs.load-config.outputs.container_version }}"
          ARCH="x86_64"

          # Create Fedora-standard repository structure
          # repo/fedora/VERSION/ARCH/ for binary RPMs
          # repo/fedora/VERSION/source/ for source RPMs
          REPO_BASE="repo/fedora/${FEDORA_VERSION}"
          mkdir -p "${REPO_BASE}/${ARCH}"
          mkdir -p "${REPO_BASE}/source"

          # Copy existing packages from gh-pages (preserving structure)
          if [ -d "gh-pages-repo/fedora" ]; then
            echo "Copying existing packages from gh-pages..."
            cp -r gh-pages-repo/fedora/* repo/fedora/ 2>/dev/null || true
          fi

          # Sort new packages into proper directories
          echo "Organizing new packages..."
          for rpm in artifacts/*.rpm; do
            if [ -f "$rpm" ]; then
              if [[ "$rpm" == *.src.rpm ]]; then
                # Source RPMs go to source/
                cp "$rpm" "${REPO_BASE}/source/"
                echo "  → $(basename "$rpm") → source/"
              else
                # Binary RPMs go to arch directory
                cp "$rpm" "${REPO_BASE}/${ARCH}/"
                echo "  → $(basename "$rpm") → ${ARCH}/"
              fi
            fi
          done

          # Verify we have packages
          if ! ls "${REPO_BASE}/${ARCH}"/*.rpm 1>/dev/null 2>&1 && \
             ! ls "${REPO_BASE}/source"/*.rpm 1>/dev/null 2>&1; then
            echo "::endgroup::"
            echo "::error::No packages found after organization"
            exit 1
          fi

          # List organized packages
          echo ""
          echo "Repository structure:"
          echo "Binary packages (${ARCH}):"
          ls -lh "${REPO_BASE}/${ARCH}"/*.rpm 2>/dev/null || echo "  (none)"
          echo ""
          echo "Source packages:"
          ls -lh "${REPO_BASE}/source"/*.rpm 2>/dev/null || echo "  (none)"

          # Generate repository metadata for binary packages
          echo ""
          echo "Generating repository metadata for ${ARCH}..."
          createrepo_c "${REPO_BASE}/${ARCH}/"

          # Generate repository metadata for source packages
          echo "Generating repository metadata for source..."
          createrepo_c "${REPO_BASE}/source/"

          # Generate top-level metadata
          echo "Generating top-level repository metadata..."
          createrepo_c repo/

          echo "✓ Repository preparation complete"
          echo "::endgroup::"

      - name: Deploy repository to GitHub Pages
        uses: peaceiris/actions-gh-pages@v4
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: repo
          keep_files: false
          # keep_files: false ensures clean deployment
          # All packages are in repo/ so nothing is lost
